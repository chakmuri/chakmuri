{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useRef, useState, useEffect } from 'react';\nimport raf from \"rc-util/es/raf\";\n/**\r\n * State generate. Return a `setState` but it will flush all state with one render to save perf.\r\n * This is not a realization of `unstable_batchedUpdates`.\r\n */\n\nexport function useBatchFrameState() {\n  var _useState = useState({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      forceUpdate = _useState2[1];\n\n  var statesRef = useRef([]);\n  var destroyRef = useRef(false);\n  var walkingIndex = 0;\n  var beforeFrameId = 0;\n  useEffect(function () {\n    return function () {\n      destroyRef.current = true;\n    };\n  }, []);\n\n  function createState(defaultValue) {\n    var myIndex = walkingIndex;\n    walkingIndex += 1; // Fill value if not exist yet\n\n    if (statesRef.current.length < myIndex + 1) {\n      statesRef.current[myIndex] = defaultValue;\n    } // Return filled as `setState`\n\n\n    var value = statesRef.current[myIndex];\n\n    function setValue(val) {\n      statesRef.current[myIndex] = typeof val === 'function' ? val(statesRef.current[myIndex]) : val;\n      raf.cancel(beforeFrameId); // Flush with batch\n\n      beforeFrameId = raf(function () {\n        if (!destroyRef.current) {\n          forceUpdate({});\n        }\n      });\n    }\n\n    return [value, setValue];\n  }\n\n  return createState;\n}","map":{"version":3,"sources":["C:/Users/seongjae98/GoogleDrive/dev/pro/chakmuri/front/node_modules/rc-overflow/es/hooks/useBatchFrameState.js"],"names":["_slicedToArray","useRef","useState","useEffect","raf","useBatchFrameState","_useState","_useState2","forceUpdate","statesRef","destroyRef","walkingIndex","beforeFrameId","current","createState","defaultValue","myIndex","length","value","setValue","val","cancel"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,0CAA3B;AACA,SAASC,MAAT,EAAiBC,QAAjB,EAA2BC,SAA3B,QAA4C,OAA5C;AACA,OAAOC,GAAP,MAAgB,gBAAhB;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,kBAAT,GAA8B;AACnC,MAAIC,SAAS,GAAGJ,QAAQ,CAAC,EAAD,CAAxB;AAAA,MACIK,UAAU,GAAGP,cAAc,CAACM,SAAD,EAAY,CAAZ,CAD/B;AAAA,MAEIE,WAAW,GAAGD,UAAU,CAAC,CAAD,CAF5B;;AAIA,MAAIE,SAAS,GAAGR,MAAM,CAAC,EAAD,CAAtB;AACA,MAAIS,UAAU,GAAGT,MAAM,CAAC,KAAD,CAAvB;AACA,MAAIU,YAAY,GAAG,CAAnB;AACA,MAAIC,aAAa,GAAG,CAApB;AACAT,EAAAA,SAAS,CAAC,YAAY;AACpB,WAAO,YAAY;AACjBO,MAAAA,UAAU,CAACG,OAAX,GAAqB,IAArB;AACD,KAFD;AAGD,GAJQ,EAIN,EAJM,CAAT;;AAMA,WAASC,WAAT,CAAqBC,YAArB,EAAmC;AACjC,QAAIC,OAAO,GAAGL,YAAd;AACAA,IAAAA,YAAY,IAAI,CAAhB,CAFiC,CAEd;;AAEnB,QAAIF,SAAS,CAACI,OAAV,CAAkBI,MAAlB,GAA2BD,OAAO,GAAG,CAAzC,EAA4C;AAC1CP,MAAAA,SAAS,CAACI,OAAV,CAAkBG,OAAlB,IAA6BD,YAA7B;AACD,KANgC,CAM/B;;;AAGF,QAAIG,KAAK,GAAGT,SAAS,CAACI,OAAV,CAAkBG,OAAlB,CAAZ;;AAEA,aAASG,QAAT,CAAkBC,GAAlB,EAAuB;AACrBX,MAAAA,SAAS,CAACI,OAAV,CAAkBG,OAAlB,IAA6B,OAAOI,GAAP,KAAe,UAAf,GAA4BA,GAAG,CAACX,SAAS,CAACI,OAAV,CAAkBG,OAAlB,CAAD,CAA/B,GAA8DI,GAA3F;AACAhB,MAAAA,GAAG,CAACiB,MAAJ,CAAWT,aAAX,EAFqB,CAEM;;AAE3BA,MAAAA,aAAa,GAAGR,GAAG,CAAC,YAAY;AAC9B,YAAI,CAACM,UAAU,CAACG,OAAhB,EAAyB;AACvBL,UAAAA,WAAW,CAAC,EAAD,CAAX;AACD;AACF,OAJkB,CAAnB;AAKD;;AAED,WAAO,CAACU,KAAD,EAAQC,QAAR,CAAP;AACD;;AAED,SAAOL,WAAP;AACD","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\r\nimport { useRef, useState, useEffect } from 'react';\r\nimport raf from \"rc-util/es/raf\";\r\n/**\r\n * State generate. Return a `setState` but it will flush all state with one render to save perf.\r\n * This is not a realization of `unstable_batchedUpdates`.\r\n */\r\n\r\nexport function useBatchFrameState() {\r\n  var _useState = useState({}),\r\n      _useState2 = _slicedToArray(_useState, 2),\r\n      forceUpdate = _useState2[1];\r\n\r\n  var statesRef = useRef([]);\r\n  var destroyRef = useRef(false);\r\n  var walkingIndex = 0;\r\n  var beforeFrameId = 0;\r\n  useEffect(function () {\r\n    return function () {\r\n      destroyRef.current = true;\r\n    };\r\n  }, []);\r\n\r\n  function createState(defaultValue) {\r\n    var myIndex = walkingIndex;\r\n    walkingIndex += 1; // Fill value if not exist yet\r\n\r\n    if (statesRef.current.length < myIndex + 1) {\r\n      statesRef.current[myIndex] = defaultValue;\r\n    } // Return filled as `setState`\r\n\r\n\r\n    var value = statesRef.current[myIndex];\r\n\r\n    function setValue(val) {\r\n      statesRef.current[myIndex] = typeof val === 'function' ? val(statesRef.current[myIndex]) : val;\r\n      raf.cancel(beforeFrameId); // Flush with batch\r\n\r\n      beforeFrameId = raf(function () {\r\n        if (!destroyRef.current) {\r\n          forceUpdate({});\r\n        }\r\n      });\r\n    }\r\n\r\n    return [value, setValue];\r\n  }\r\n\r\n  return createState;\r\n}"]},"metadata":{},"sourceType":"module"}